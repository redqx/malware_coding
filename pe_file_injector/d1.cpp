#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>



#define BUFFER_SIZE 1024

IMAGE_DOS_HEADER* lp_Dos;
IMAGE_FILE_HEADER* lp_FileHeader;
IMAGE_OPTIONAL_HEADER64* lp_option64;
IMAGE_OPTIONAL_HEADER32* lp_option32;
IMAGE_IMPORT_DESCRIPTOR* lp_ImportDescriptor;
IMAGE_SECTION_HEADER* lp_SectionHeaders;

int isx86;
DWORD flen;


/**
 * 函数名称：peFileMapping
 * 函数功能：其实就是读取二进制文件,然后把内容dump出来
 * 输入参数：
 *   - 参数1：char* 文件路径
 * 返回值：开辟的内容,内容是文件的dump
 * 函数的前提: 无
 */
BYTE* my_FileMapping(CHAR* szFileName)
{
    HANDLE hFile;
    DWORD dwFileSize, dwBytesRead;
    BYTE* lpBuffer = NULL;

    hFile = CreateFileA(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        _tprintf(TEXT("Failed to open file, error code: %d\n"), GetLastError());
        return NULL;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE)
    {
        _tprintf(TEXT("Failed to get file size, error code: %d \n"), GetLastError());
        CloseHandle(hFile);
        return NULL;
    }

    lpBuffer = (PBYTE)malloc(dwFileSize + 1024);
    if (lpBuffer == NULL)
    {
        _tprintf(TEXT("Failed to allocate memory for file content, error code: %d\n"), GetLastError());
        CloseHandle(hFile);
        return NULL;
    }
    memset(lpBuffer, 0, dwFileSize + 1024);
    if (!ReadFile(hFile, lpBuffer, dwFileSize, &dwBytesRead, NULL))
    {
        _tprintf(TEXT("Failed to read file content, error code: %d\n"), GetLastError());
        free(lpBuffer);
        CloseHandle(hFile);
        return NULL;
    }

    // Add NULL terminator at the end of the buffer
    flen = dwBytesRead;
    CloseHandle(hFile);
    return lpBuffer;
}
DWORD va2fa(DWORD va)
{
    int len;
    int i;
    len = lp_FileHeader->NumberOfSections;
    if (va == -1)
    {
        return -1;
    }
    if (isx86 && va > lp_option32->SizeOfImage)//x86的
    {
        return -1;
    }
    else if (va > lp_option64->SizeOfImage)//x64的
    {
        return -1;
    }

    for (i = 0; i < len - 1; i++)
    {
        if (va >= lp_SectionHeaders[i].VirtualAddress && va <= lp_SectionHeaders[i + 1].VirtualAddress)
        {
            break;
        }
    }
    return va - lp_SectionHeaders[i].VirtualAddress + lp_SectionHeaders[i].PointerToRawData;
}
DWORD fa2va(DWORD fa)
{
    int len;
    int i;
    len = lp_FileHeader->NumberOfSections;
    if (fa == -1 || fa > flen)
    {
        return -1;
    }
    for (i = 0; i < len - 1; i++)
    {
        if (fa >= lp_SectionHeaders[i].PointerToRawData && fa <= lp_SectionHeaders[i + 1].PointerToRawData)
        {
            break;
        }
    }
    return fa - lp_SectionHeaders[i].PointerToRawData + lp_SectionHeaders[i].VirtualAddress;
}
void setSection_Write(DWORD fa) {
    int len;
    int i;
    len = lp_FileHeader->NumberOfSections;
    for (i = 0; i < len - 1; i++)
    {
        if (fa >= lp_SectionHeaders[i].PointerToRawData && fa <= lp_SectionHeaders[i + 1].PointerToRawData)
        {
            break;
        }
    }
    //出来就是那个节区了,,一定会找到的
    lp_SectionHeaders[i].Characteristics = lp_SectionHeaders[i].Characteristics | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ;
    return;
}
BOOL readPEinfo(CHAR* filename)
{
    lp_Dos = (IMAGE_DOS_HEADER*)my_FileMapping(filename);
    if ((void*)lp_Dos == NULL)
    {
        _tprintf(TEXT("wrong file mapping\n"));
        return FALSE;
    }
    lp_FileHeader = (IMAGE_FILE_HEADER*)(lp_Dos->e_lfanew + (char*)lp_Dos + 4);
    lp_option64 = (IMAGE_OPTIONAL_HEADER64*)((char*)lp_FileHeader + sizeof(IMAGE_FILE_HEADER));
    lp_option32 = (IMAGE_OPTIONAL_HEADER32*)lp_option64;

    if (lp_FileHeader->Machine == IMAGE_FILE_MACHINE_AMD64)
    {
        isx86 = 0;
        lp_SectionHeaders = (IMAGE_SECTION_HEADER*)((char*)lp_option64 + sizeof(IMAGE_OPTIONAL_HEADER64));
        lp_ImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)(va2fa(lp_option64->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) + (char*)lp_Dos);//VA>FA>
    }
    else if (lp_FileHeader->Machine == IMAGE_FILE_MACHINE_I386)
    {
        isx86 = 1;
        lp_SectionHeaders = (IMAGE_SECTION_HEADER*)((char*)lp_option32 + sizeof(IMAGE_OPTIONAL_HEADER32));
        lp_ImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)(va2fa(lp_option32->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) + (char*)lp_Dos);//VA>FA>
    }
    else
    {
        _tprintf(TEXT("not pe file\n"));
        free(lp_Dos);
        return FALSE;
    }
}

/*
 * 函数名称：couldInsert
 * 函数功能：判断在原来导入表的基础上,判断是否可以增加一个导入表(不需要寻新的内存那种)
 * 输入参数：无
 * 返回值：
 *  - 1 表示可以增加,在原来基础上增加
 *  - 0 表示不可以在原来基础上增加
 */
BOOL can_be_Insert(DWORD* index)
{
    //空2个导入表,就可以添加一个新的导入表
    //一个导入表大小20字节

    char zeroArea[sizeof(IMAGE_IMPORT_DESCRIPTOR)];
    int i = 0;

    memset(zeroArea, 0, sizeof(IMAGE_IMPORT_DESCRIPTOR));//一个导入表的大小
    while (lp_ImportDescriptor[i].Name)
    {
        i++;
    }
    //出来的i是空白节区
    *index = i;//这个i可能是我们要插入的地方

    if (!memcmp(&lp_ImportDescriptor[i + 1], zeroArea, sizeof(IMAGE_IMPORT_DESCRIPTOR)))//观察空白节区的下一个节区
    {
        return TRUE;//可以在原来基础上插入
    }
    else
    {
        return FALSE; //不能在原来基础上插入
    }
}
/*
 * 函数名称：smallFindZero
 * 函数功能：判断一块连续的为零的内存
 * 输入参数:
 *  - 参数1: 判断的起始地址
 *  - 参数2: 判断结束的地址
 * 返回值：
 *  - 为零区域的长度
 *  - 1 表示继续遍历
 */
DWORD findNextZeroArea_lenght(BYTE* lp_Start, BYTE* lp_End)
{
    DWORD i;
    for (i = 0; (lp_Start < lp_End) && (*lp_Start == 0); i++)
    {
        lp_Start++;//这里面也可能会溢出
    }
    if (i == 0)
    {
        return 1;//继续往后遍历,i++
    }
    return i;//返回那块为零的区域的长度
}
/*
 * 函数名称：cloudMove
 * 函数功能：判断是否可以迁移整个导入表到已有的内存区域
 * 输入参数:
 *  - 参数1: 导入表计划的长度
 * 返回值：
 *  - 0 表示,无法迁移
 *  - 1 可以迁移,返回迁移的FA地址
 */
DWORD FindZeroArea(int addLen)//对导入表搬家,
{
    BYTE* lp_Start, * lp_End;
    DWORD FA_Start = 0;
    DWORD cnt;
    int i = 0;

    //去data节去找吧...正常情况下都会有一个data节区的

    while (lp_SectionHeaders[i].PointerToRawData == 0) {
        i++;
    }
    lp_Start = (BYTE*)(lp_SectionHeaders[i].PointerToRawData + (char*)lp_Dos);
    lp_End = lp_Start + flen;


    while ((lp_Start < lp_End))
    {
        cnt = findNextZeroArea_lenght(lp_Start, lp_End);//从lp_Start开始判断一块连续的空白内存区域
        //lp_Start += cnt;
        if (cnt >= addLen)//找那个最大的区域,并且地址是4的倍数
        {
            //长度得满足
            //地址是16的倍数
            if ((LONG_PTR)lp_Start % 16 == 0) {
                _tprintf(TEXT("%08X:%08X\n"), FA_Start, cnt);
                //我需要知道这个东西在哪一个节区...然后设置该节区是一个可以写入的属性
                return (LONG_PTR)lp_Start - (LONG_PTR)lp_Dos;
            }
            else {
                lp_Start += 1;
            }
        }
        else {
            lp_Start += cnt;
        }
    }
    return 0;
}
DWORD falien(DWORD checkLen)
{
    int Falien;
    if (isx86)
    {
        Falien = lp_option32->FileAlignment;
    }
    else
    {
        Falien = lp_option64->FileAlignment;
    }
    if (checkLen % Falien)//没对齐
    {
        checkLen = (checkLen / Falien + 1) * Falien;
    }
    return checkLen;
}
/*
其实现在又有一个问题,,,
那就是IAT表是可写入的,,,所以在你寻找文件的空白区域的时候
然后选择了一个不可写入的节区,,,那么就会导致api地址写入失败
所以我们还得找一个可以写入的区域?
*/

void inject_Dll(char* dllName, char* funcName)
{
    DWORD tmp;
    DWORD fa_start;
    DWORD index;
    DWORD newImportSzie;
    DWORD newImportSziePadding = 0;
    IMAGE_IMPORT_DESCRIPTOR* tlp_ImportDescriptor;
    tmp = can_be_Insert(&index);

    //如果需要新开辟迁移导入表,index表示原来的导入表个数..但是我们要新增加一个,,同时我们还需要保持新增加的后面为空白的区域
    //所以个数就是index+1+1
    newImportSzie = (index + 2) * sizeof(IMAGE_IMPORT_DESCRIPTOR) + 4 * 16;//64是导入表具体指向的4行

    if (tmp == 1)
    {
        //可以直接插入,最好的情况
        fa_start = FindZeroArea(16 * 4);
        if (fa_start == 0)
        {
            //还是空间不足
            goto label1;
        }
        tlp_ImportDescriptor = lp_ImportDescriptor;
    }
    else
    {
    label1:

        fa_start = FindZeroArea(newImportSzie);
        if (fa_start)//完全迁移导入表,不需要增加文件大小
        {
            //可以迁移
            tlp_ImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)(fa_start + (BYTE*)lp_Dos);
            memcpy(fa_start + (BYTE*)lp_Dos, lp_ImportDescriptor, index * sizeof(IMAGE_IMPORT_DESCRIPTOR));//把原来的复制过去
        }
        else//增加文件大小的方式添加导入表,//最后一个节区不一定是可以写入的
        {
            fa_start = flen;
            tlp_ImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)(fa_start + (BYTE*)lp_Dos);
            newImportSziePadding = falien(newImportSzie);//新增加多少字节
            //尾部增加
            memcpy(fa_start + (BYTE*)lp_Dos, lp_ImportDescriptor, index * sizeof(IMAGE_IMPORT_DESCRIPTOR));
            if (isx86)
            {
                lp_option32->SizeOfImage += newImportSziePadding;
                //节区扩大
            }
            else
            {
                lp_option64->SizeOfImage += newImportSziePadding;
            }
            lp_SectionHeaders[lp_FileHeader->NumberOfSections - 1].SizeOfRawData += newImportSziePadding;
            lp_SectionHeaders[lp_FileHeader->NumberOfSections - 1].Misc.VirtualSize += newImportSziePadding;
            //并且要设置节是可以写的权限?
            flen += newImportSziePadding;
        }

        if (isx86) {
            lp_option32->DataDirectory[1].VirtualAddress = fa2va(fa_start);
            lp_option32->DataDirectory[1].Size += sizeof(IMAGE_IMPORT_DESCRIPTOR);
        }
        else {
            lp_option64->DataDirectory[1].VirtualAddress = fa2va(fa_start);
            lp_option64->DataDirectory[1].Size += sizeof(IMAGE_IMPORT_DESCRIPTOR);
        }
        fa_start = fa_start + (index + 2) * sizeof(IMAGE_IMPORT_DESCRIPTOR);

    }
    setSection_Write(fa_start);

    //写入dll的名字
    memcpy(fa_start + (BYTE*)lp_Dos, dllName, strlen(dllName)); //第1行
    //写入函数的name结构体
    memcpy(fa_start + 16 + 2 + (BYTE*)lp_Dos, funcName, strlen(funcName));//第2行


    tmp = fa2va(fa_start + 16);

    //往INT写入数据(第2行)
    memcpy(fa_start + 32 + (BYTE*)lp_Dos, &tmp, 4);
    //往IAT写入数据(第2行)
    memcpy(fa_start + 48 + (BYTE*)lp_Dos, &tmp, 4);

    tlp_ImportDescriptor[index].Name = fa2va(fa_start);//指向第1行
    tlp_ImportDescriptor[index].OriginalFirstThunk = fa2va(fa_start + 32);//指向第3行
    tlp_ImportDescriptor[index].FirstThunk = fa2va(fa_start + 48);//指向第4行

    return;
}
void writeIntoFIle(CHAR* filename)
{
    BOOL bResult;
    HANDLE hFile = CreateFileA(
        filename,   // 文件名
        GENERIC_WRITE,     // 访问权限为写入
        0,                 // 共享模式，这里设为0表示无共享
        NULL,              // 安全属性，这里设为NULL
        CREATE_ALWAYS,     // 创建文件方式，如果已存在则覆盖
        FILE_ATTRIBUTE_NORMAL, // 文件属性，这里设为普通文件
        NULL               // 模板文件句柄，这里设为NULL
    );
    if (hFile == INVALID_HANDLE_VALUE) {
        // 处理失败情况
    }
    bResult = WriteFile(
        hFile,               // 文件句柄
        lp_Dos,            // 要写入的数据缓冲区
        flen,              // 要写入的字节数
        NULL,                // 实际写入的字节数（可选）
        NULL                 // 异步操作（可选）
    );
    if (!bResult) {
        // 处理失败情况
    }
    CloseHandle(hFile);
    return;
}
int main(int argc, CHAR* argv[])
{
    CHAR path_bak[256] = { 0 };
    char* APIName;
    char* dllName;
    if (argc != 4) {
        _tprintf(TEXT("USAGE: self.exe target_exe dllName APIname\n\n"));
        return 0;
    }
    sprintf(path_bak, "%s.patch", argv[1]);
    dllName = argv[2];
    APIName = argv[3];

    if (readPEinfo(argv[1])) {
        inject_Dll(dllName, APIName);
        writeIntoFIle(path_bak);
    }
    free(lp_Dos);
    return 0;

}