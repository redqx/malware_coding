#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <string.h>
#include <tlhelp32.h>

BOOL is_x86;
LPVOID lp_orgWriteFile = NULL;
CREATE_PROCESS_DEBUG_INFO g_cpdi;
BYTE int3 = 0xCC, asm_old = 0;

 
/*

BOOL
WINAPI
WriteFile(
    _In_ HANDLE hFile,
    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,
    _In_ DWORD nNumberOfBytesToWrite,
    _Out_opt_ LPDWORD lpNumberOfBytesWritten,
    _Inout_opt_ LPOVERLAPPED lpOverlapped
    );
    */

/*
* 函数名: write0xCC
* 函数参数:
*  - 参数1: 不知道具体含义
* 函数功能: hook writefile的API,方便后面触发异常
*/

char* gen_shellcode_injectDll_v1()
{
    HMODULE hModule;
    char* retData = NULL;
    hModule = GetModuleHandle(TEXT("kernel32.dll"));
    if (hModule) {
        retData = (char*)GetProcAddress(hModule, "WriteFile");
        if (retData) {
            return retData;
        }
    }

    return retData;
} 
BOOL write0xCC(LPDEBUG_EVENT pde)
{
    HMODULE hModule;
    char* retData = NULL;
    hModule = GetModuleHandle(TEXT("kernel32.dll"));
    retData = (char*)GetProcAddress(hModule, "WriteFile");
    lp_orgWriteFile = retData;

    // API Hook - WriteFile()
    memcpy(&g_cpdi, &pde->u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO));
    ReadProcessMemory(g_cpdi.hProcess, lp_orgWriteFile, &asm_old, 1, NULL);   //把原始的字节保存到asm_old
    WriteProcessMemory(g_cpdi.hProcess, lp_orgWriteFile, &int3, 1, NULL);    //往对应的地址那里写入0xCC

    return TRUE;
}
/*
* 函数名:  handler_0xCC
* 函数参数:
*  - 参数1: 不知道具体含义
* 功能:
*   处理int3的异常事件,也就是目标进程发生writefile的时候,本进程该怎么处理
*/


BOOL handler_0xCC(LPDEBUG_EVENT pde)
{
    //分别对应了x86和x64的上下文
    CONTEXT ctx = { 0 };
    PBYTE lpBuffer = NULL;
    size_t dwNumOfBytesToWrite;
    PVOID dwAddrOfBuffer;
    PEXCEPTION_RECORD per = &pde->u.Exception.ExceptionRecord;
    int i;

    // BreakPoint exception (INT 3)
    if (EXCEPTION_BREAKPOINT == per->ExceptionCode || per->ExceptionCode == 0x4000001F)//如果异常事件是0xCC
    {
        //STATUS_WX86_BREAKPOINT 0x4000001F x86的int3
        //EXCEPTION_BREAKPOINT  0x80000003 x64的int3
        if (lp_orgWriteFile == per->ExceptionAddress)
        {
            WriteProcessMemory(g_cpdi.hProcess, lp_orgWriteFile, &asm_old, sizeof(BYTE), NULL); //脱去钩子
#ifdef _M_IX86
  
            ctx.ContextFlags = CONTEXT_CONTROL;
            GetThreadContext(g_cpdi.hThread, (LPCONTEXT)&ctx);
            //   param 2 : ESP + 0x8  LPCVOID lpBuffer
            //   param 3 : ESP + 0xC  nNumberOfBytesToWrite
            ReadProcessMemory(g_cpdi.hProcess, (LPCVOID)(ctx.Esp + 8), &dwAddrOfBuffer, sizeof(DWORD), NULL);
            ReadProcessMemory(g_cpdi.hProcess, (LPCVOID)(ctx.Esp + 12), &dwNumOfBytesToWrite, sizeof(DWORD), NULL);
#else
            ctx.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
            GetThreadContext(g_cpdi.hThread, (LPCONTEXT)&ctx);
            dwAddrOfBuffer = (PVOID)ctx.Rdx;//rdx ; lpBuffe
            dwNumOfBytesToWrite = ctx.R8;//r8d nNumberOfBytesToWrite
#endif
            // #4. 分配临时缓冲区
            lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite + 1);
            memset(lpBuffer, 0, dwNumOfBytesToWrite + 1);

            // #5. WriteFile() 复制记事本内容到lp_Buffer
            ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL);

            // #6. 加密
            for (i = 0; i < dwNumOfBytesToWrite; i++){
                lpBuffer[i] ^= 0x17;
            }
            // #7. 把转化后的数据写入到notepad的缓冲区
            WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL);

            // #8. 释放
            free(lpBuffer);
#ifdef _M_IX86
            // #9. Thread Contex 把线程上下文的ip地址设置为lp_orgWriteFile
            ctx.Eip = (DWORD)lp_orgWriteFile;
            SetThreadContext(g_cpdi.hThread, (LPCONTEXT)&ctx);
#else
            // #9. Thread Contex 把线程上下文的ip地址设置为lp_orgWriteFile
            ctx.Rip = (DWORD64)lp_orgWriteFile;
            SetThreadContext(g_cpdi.hThread, (LPCONTEXT)&ctx);
#endif

            // #10. Debuggee 继续运行被调试者 下面3句代码很重要
            ContinueDebugEvent(pde->dwProcessId, pde->dwThreadId, DBG_CONTINUE);
            Sleep(1000);//执行完毕
            WriteProcessMemory(g_cpdi.hProcess, lp_orgWriteFile, &int3, sizeof(BYTE), NULL);//再次挂钩子
            return TRUE;
        }
    }

    return FALSE;
}
/*
* 名字:debugWhile
* 参数:无参数
* 作用: 不断的处理被调试进程的事件
*/
void debugWhile()
{
    DEBUG_EVENT de;//调试事件
    DWORD dwContinueStatus;


    //等待被调试的notepad发生一个事件,然后把信号发过来
    while (WaitForDebugEvent(&de, INFINITE))//不断的去进行一个调试器的消息循环
    {
        dwContinueStatus = DBG_CONTINUE;//被调试者选择 继续执行
        if (CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode)//调试进程生成或者附加事件,只会发生一次
        {
            write0xCC(&de);//对 API:Writefile函数写入0xcc
        }
        else if (EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode)//被调试的notepad发生了异常事件,通常是0xCC
        {
            //默认int3异常是我们触发的
            if (handler_0xCC(&de))//除以0xcc的异常
            {
                //内部有 ContinueDebugEvent
                continue;
            }
        }
        // 被调试进程终止
        else if (EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode)
        {
            //被调试的对象发来结束信号
            break;//调试器也退出
        }

        //调试器,调试对象继续执行
        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus);//调速器继续运行
    }
}
DWORD FindProcessID_byName(TCHAR* szProcessName)//
{
    DWORD dwPID = 0;
    HANDLE hSnapShot;
    PROCESSENTRY32 pe;

    // Get the snapshot of the system
    pe.dwSize = sizeof(PROCESSENTRY32);
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, 0);

    // find process
    Process32First(hSnapShot, &pe);
    do
    {
        if (!_tcscmp(szProcessName, pe.szExeFile))
        {
            dwPID = pe.th32ProcessID;
            break;
        }
    } while (Process32Next(hSnapShot, &pe));

    CloseHandle(hSnapShot);
    return dwPID;
 }
int _tmain(int argc, TCHAR* argv[])
{
    DWORD dwPID = 0;
    HANDLE hProcess;
 

    if (argc != 2)//pid button dllPath
    {
        _tprintf(TEXT("USAGE: self.exe processname \n"));
        return 0;
    }
    dwPID = FindProcessID_byName(argv[1]);

    if (dwPID)
    {
        //获取目标进程架构 因为hook x86和x64的不一样
        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwPID);
        IsWow64Process(hProcess, &is_x86);
        CloseHandle(hProcess);
#ifdef _M_IX86
        if (is_x86) {
#else
        if (!is_x86) {
#endif

            if (!DebugActiveProcess(dwPID))//让目标进程被我调试
            {
                _tprintf(TEXT("DebugActiveProcess failed with Error  %d\n"), GetLastError());
                return 0;
            }
            debugWhile();//进入一个消息循环
        }
        else {
             _tprintf(TEXT("USAGE: arch is not correct\n"));
             return 0;
        }

    }
    else {
        _tprintf(TEXT("not found\n"));
    }
    return 0;
}
