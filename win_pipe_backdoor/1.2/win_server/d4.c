#define _CRT_SECURE_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include <WinSock2.h>  
#include <stdio.h>
#pragma comment(lib,"ws2_32.lib")

int stri_memcmp(char* x,char*y,int len){
	int i;
	char* x1 = malloc(len + 1);
	char* y1 = malloc(len + 1);

	memcpy(x1, x, len);
	memcpy(y1, y, len);

	for (i=0; i < len; i++) {
		x1[i] = x1[i] | 32;
		y1[i] = y1[i] | 32;
	}
	return memcmp(x1, y1, len);

}
//这个len好像没啥用
void UTF8_send(SOCKET sockClient, char* sendBuf, int len, int flag){

	// 将字符串从当前编码（如GBK）转换为UTF-8编码
	int bufferSize = MultiByteToWideChar(CP_ACP, 0, sendBuf, -1, NULL, 0);
	wchar_t* wideStr = (wchar_t*)malloc(bufferSize * sizeof(wchar_t));
	MultiByteToWideChar(CP_ACP, 0, sendBuf, -1, wideStr, bufferSize);

	bufferSize = WideCharToMultiByte(CP_UTF8, 0, wideStr, -1, NULL, 0, NULL, NULL);
	char* utf8Str = (char*)malloc(bufferSize * sizeof(char));
	WideCharToMultiByte(CP_UTF8, 0, wideStr, -1, utf8Str, bufferSize, NULL, NULL);

	send(sockClient, utf8Str, strlen(utf8Str), flag);
	free(wideStr);
	free(utf8Str);

}
DWORD WINAPI ClientThread(LPVOID lpParam) 
{
	SOCKET ss = *((SOCKET*)lpParam);
	DWORD cid;
	int retVal;
	char *recvBuf = malloc(4096);
	char *sendBuf = malloc(4096);

	cid = GetCurrentThreadId();
	printf("%08X.#>: weclome!!! ^-^\n", cid);
	while (1)
	{
		//接收消息
		//printf("%08X.#>:\n", cid);
		memset(recvBuf, 0, 4096);
		retVal = recv(ss, recvBuf, 4096, 0);
		//判断客户端是否关闭连接
		if (SOCKET_ERROR == retVal) {
			printf("failed !\n");
			break;
		}
		printf("%s\n", (WCHAR*)recvBuf);
	tag:
		printf("%08X.#>: ", cid);
		fflush(stdin);
		memset(sendBuf, 0, 4096);
		fgets(sendBuf, 4096, stdin);

		if (stri_memcmp(sendBuf, "cls", 3) == 0){
			system("cls");
			goto tag;
		}
		if (stri_memcmp(sendBuf, "exit",4) == 0){
			UTF8_send(ss, "exit", 4, 0);
			break;
		}
		UTF8_send(ss, sendBuf, strlen(sendBuf), 0);
	}
	printf("%08X.#>: Good Bye -_- \nwait next one to connect....\n", cid);
	closesocket(ss);
	free(recvBuf);
	free(sendBuf);
	return 0;
}
int main(int argc, char* argv[])
{
	//定义需要使用的变量
	WSADATA wsaData;
	SOCKET sockListen, sockConn;
	SOCKADDR_IN ListenAddr, ConnAddr;
	int tmpNum;
	char *endptr;
	if (argc != 2){
		printf("USAGE: self.exe port\n");
		return -1;
	}

	tmpNum = strtol(argv[1], &endptr, 10);

	if (endptr == argv[1]) {
		printf("无效的输入\n");
		return -1;
	}
	else if (*endptr != '\0') {
		printf("转换到非数字字符：%c\n", *endptr);
		return -1;
	}

	printf("00000000.#> work with 127.0.0.1 %d\n", tmpNum);
	//准备环境


	// 设置控制台输出为UTF-8编码
	SetConsoleOutputCP(CP_UTF8);

	// 设置控制台输入为UTF-8编码
	//SetConsoleCP(CP_UTF8);

	WSAStartup(MAKEWORD(2, 2), &wsaData);
	//创建一个电话
	sockListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	if (sockListen == INVALID_SOCKET) {
		printf("socket failed\n");
	}

	//买一个电话卡
	ListenAddr.sin_addr.S_un.S_addr = INADDR_ANY;  //如果对ip地址不关心的话，可设置为 INADDR_ANY
	ListenAddr.sin_family = AF_INET;
	ListenAddr.sin_port = htons(tmpNum);

	//把电话卡插入电话
	if (SOCKET_ERROR == bind(sockListen, (SOCKADDR*)&ListenAddr, sizeof(SOCKADDR))) {

		printf("bind is error with %d\n", WSAGetLastError());
	}

	//电话开机
	printf("00000000.#> i am working ^-^ \n");
	if (SOCKET_ERROR == listen(sockListen, 5)) {

		printf("listen is error with %d\n", WSAGetLastError());
	}

	int socklen = sizeof(ConnAddr);

	while (1) {
		//接听电话
		sockConn = accept(sockListen, (SOCKADDR*)&ConnAddr, &socklen);
		//每接收一个链接，就创建一个线程来处理相应的消息
		HANDLE hThred = CreateThread(NULL, 0, ClientThread, (LPVOID)&sockConn, NULL, NULL);
		WaitForSingleObject(hThred, -1);
	}
	//关闭套接字和终止套接字库的使用
	closesocket(sockListen);
	WSACleanup();
	return 0;
}
